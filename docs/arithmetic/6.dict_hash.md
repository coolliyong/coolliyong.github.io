# 字典

> 集合、字典和散列表可以存储不重复的值。在集合中，我们感兴趣的是每个值本身，并把它当作主要元素。在字典中，我们用[键，值]的形式来存储数据。在散列表中也是一样（也是以[键，值]对的形式来存储数据）。但是两种数据结构的实现方式略有不同，本章中将会介绍。

> 集合表示一组互不相同的元素（不重复的元素）。在字典中，存储的是[键，值]对，其中键名是用来查询特定元素的。字和集合很相似，集合以[值，值]的形式存储元素，字典则是以[键，值]的形式来存储元素。字典也称作映射。

```js
function Dictionary() {
  this.item = {}
}

Dictionary.prototype.set = function(key, val) {
  this.item[key] = val
}

Dictionary.prototype.has = function(key) {
  return this.item.hasOwnProperty(key)
}

Dictionary.prototype.get = function(key) {
  if (this.has(key)) {
    return this.item[key]
  }
}

Dictionary.prototype.delete = function(key) {
  if (this.has(key)) {
    delete this.item[key]
    return true
  }
  return false
}

Dictionary.prototype.keys = function(key) {
  return Object.keys(this.item)
}

Dictionary.prototype.values = function(key) {
  return Object.values(this.item)
}

Dictionary.prototype.size = function() {
  return Object.keys().length
}

const coolliyong = new Dictionary()

coolliyong.set('github', 'coolliyong.github.io')
coolliyong.set('email', 'liyong857637472@163.com')
coolliyong.set('language', 'javascript')

console.log(coolliyong.has('address')) // false

console.log(coolliyong.get('email')) // liyong857637472@163.com

console.log(coolliyong.keys()) // [ 'github', 'email', 'language' ]
console.log(coolliyong.values()) // [ 'coolliyong.github.io', 'liyong857637472@163.com', 'javascript' ]
```

# 散列

## 维基百科定义:

> **散列表（Hash table，也叫哈希表 HashMap ）**，是根据键（Key）而直接访问在内存存储位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做散列函数，存放记录的数组称做散列表。

> 一个通俗的例子是，为了查找电话簿中某人的号码，可以创建一个按照人名首字母顺序排列的表（即建立人名 x 到首字母 F(x)的一个函数关系），
> 在首字母为 `W` 的表中查找“`王`”姓的电话号码，显然比直接查找就要快得多。这里使用人名作为关键字，`“取首字母”`是这个例子中散列函数的函数法则 F()，
> 存放首字母的表对应散列表。关键字和函数法则理论上可以任意确定。

#### 散列函数(哈希函数)

> 散列函数（英语：Hash function）又称散列算法、哈希函数，是一种从任何一种数据中创建小的数字“指纹”的方法。散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来。该函数将数据打乱混合，重新创建一个叫做散列值（hash values，hash codes，hash sums，或 hashes）的指纹。散列值通常用一个短的随机字母和数字组成的字符串来代表。好的散列函数在输入域中很少出现散列冲突。在散列表和数据处理中，不抑制冲突来区别数据，会使得数据库记录更难找到。

!['hash_map_example'](/imgs/datatype/hashmap_example_1.png)

## 代码实现

1. 常见实现: `数组 + 链表`
2. 常见实现: `数组 + 二叉树`

#### 需要实现的方法

- put(key,value)：向散列表增加一个新的项（也能更新散列表）。
- remove(key)：根据键值从散列表中移除值。
- get(key)：返回根据键值检索到的特定的值。

```js
function HashMap() {
  this.table = []
}

HashMap.prototype.put = function(key, val) {
  const _key = this.loseloseHashCode(key)
  this.table[_key] = val
}

/**
 * 简单的散列函数
 * @param {String} key
 * @returns {String}
 */
HashMap.prototype.loseloseHashCode = function(key) {
  let hash = 0
  for (let i = 0; i < key.length; i++) {
    hash += key.charCodeAt(i)
  }
  return hash % 37
}

HashMap.prototype.get = function(key) {
  const _key = this.loseloseHashCode(key)
  if (this.has(_key)) {
    return this.table[_key]
  }
}

HashMap.prototype.remove = function(key) {
  const _key = this.loseloseHashCode(key)
  if (this.has(_key)) {
    this.table[_key] = undefined
    return true
  }
}

HashMap.prototype.has = function(key) {
  return this.table[key] !== undefined
}

const emailTable = new HashMap()

emailTable.put('coolliyong', 'liyong857637472@163.com')
emailTable.put('qqemail', '857637472@qq.com')

console.log(emailTable.get('coolliyong')) // liyong857637472@163.com
console.log(emailTable.get('qqemail')) // 857637472@qq.com
console.log(emailTable.get('999')) // undefined
```

!['hash_map_example'](/imgs/datatype/hashmap_example_2.png)

## 冲突处理

以上是基于数组 + 散列函数 来实现，这时候可能会产生冲突，如果我弟弟的名字是 liyongcool (名字一样，顺序不同)，散列函数算出来的结果是一致的，然后他就覆盖了我的邮箱...这就是**冲突**

```js
emailTable.put('liyongcool', '857637472@qq.com')
console.log(emailTable.get('coolliyong')) //  857637472@qq.com
```

- 解决办法

1. 分离链接、线
2. 性探查和
